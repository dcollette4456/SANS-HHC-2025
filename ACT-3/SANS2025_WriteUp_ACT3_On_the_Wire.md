# On the Wire

**Challenge Type:** Protocol Analysis, Signal Decoding, Cryptography  
**Difficulty:** ⭐⭐⭐⭐ (4/5)  
**Status:** IN PROGRESS  
**Author:** SFC David P. Collette, Regional Cyber Center - Korea (RCC-K)

---

## Table of Contents

1. [Challenge Overview](#challenge-overview)
2. [Technical Background](#technical-background)
3. [Initial Reconnaissance](#initial-reconnaissance)
4. [Signal Capture Methodology](#signal-capture-methodology)
5. [Protocol Decoding](#protocol-decoding)
6. [Decryption Attempts](#decryption-attempts)
7. [Extended Capture Solution](#extended-capture-solution)
8. [Tools and Scripts](#tools-and-scripts)
9. [Lessons Learned](#lessons-learned)
10. [References](#references)

---

## Challenge Overview

### The Challenge

The "On the Wire" challenge presents a live signal oscilloscope interface at [https://signals.holidayhackchallenge.com/](https://signals.holidayhackchallenge.com/) displaying three different serial communication protocols transmitting simultaneously:

- **1-Wire** (Dallas/Maxim protocol) - Single data line (DQ)
- **SPI** (Serial Peripheral Interface) - MOSI (data) and SCK (clock)
- **I2C** (Inter-Integrated Circuit) - SDA (data) and SCL (clock)

### Objective

Decode the signals to find an XOR encryption key, then use it to decrypt a hidden message containing the flag.

### Challenge Hint

The challenge description provides critical clues:
- "I2C has multiple devices on shared bus"
- "Check MSB vs LSB bit order carefully"
- "Buffer complete transmission (500ms inactivity or full loop)"
- "May need to wait for broadcast loop start"

---

## Technical Background

### 1-Wire Protocol (Dallas/Maxim)

1-Wire is a device communications bus system designed by Dallas Semiconductor (now Maxim Integrated) using a single data line plus ground for both power and communication.

**Key Characteristics:**
- Single bidirectional data line (DQ)
- Master-slave architecture
- Time-slot based protocol
- Used in temperature sensors, EEPROMs, authentication chips

**Protocol Timing:**
- **Reset/Presence:** Master pulls low 480μs, waits 60-240μs for slave response
- **Write 1:** Master pulls low 1-15μs
- **Write 0:** Master pulls low 60-120μs
- **Read:** Master pulls low 1-15μs, samples within 15μs

### SPI Protocol (Serial Peripheral Interface)

SPI is a synchronous serial communication protocol developed by Motorola, commonly used for short-distance communication between microcontrollers and peripheral devices.

**Key Characteristics:**
- Full-duplex synchronous communication
- Master-slave architecture with separate clock
- Separate data lines for input/output
- No acknowledgment mechanism

**Signal Lines:**
- **SCK (Serial Clock):** Clock signal generated by master
- **MOSI (Master Out Slave In):** Data from master to slave
- **MISO (Master In Slave Out):** Data from slave to master
- **SS/CS (Slave Select/Chip Select):** Slave selection

**Configuration Parameters:**
- **Clock Polarity (CPOL):** Idle state of clock (0 = low, 1 = high)
- **Clock Phase (CPHA):** Data capture edge (0 = leading, 1 = trailing)
- **Bit Order:** MSB-first (most common) or LSB-first
- **Data Rate:** Typically MHz range

**SPI Modes:**

| Mode | CPOL | CPHA | Clock Idle | Data Capture Edge |
|------|------|------|------------|-------------------|
| 0    | 0    | 0    | Low        | Rising            |
| 1    | 0    | 1    | Low        | Falling           |
| 2    | 1    | 0    | High       | Rising            |
| 3    | 1    | 1    | High       | Falling           |

### I2C Protocol (Inter-Integrated Circuit)

I2C (also written I²C) is a synchronous, multi-master, multi-slave, packet switched serial communication protocol invented by Philips Semiconductor (now NXP).

**Key Characteristics:**
- Two-wire shared bus (SDA + SCL)
- Multi-master, multi-slave capable
- 7-bit or 10-bit addressing
- Built-in acknowledgment mechanism
- Common speeds: 100 kHz (Standard), 400 kHz (Fast), 1 MHz (Fast Plus)

**Transaction Structure:**

```
START → ADDRESS (7 bits) → R/W (1 bit) → ACK → DATA BYTE → ACK → ... → STOP
```

**Bus Conditions:**
- **START:** SDA falls while SCL high
- **STOP:** SDA rises while SCL high
- **Data Valid:** SDA stable while SCL high
- **ACK:** Slave pulls SDA low during 9th clock pulse
- **NAK:** SDA remains high during 9th clock pulse

**Address Byte Structure:**
```
[A6 A5 A4 A3 A2 A1 A0 R/W]
 └─────── 7-bit address ──┘  └─ 0=Write, 1=Read
```

---

## Initial Reconnaissance

### Challenge Interface Analysis

Upon accessing the challenge URL, we encountered a multi-tab interface showing live oscilloscope displays for each protocol:

1. **1-Wire Tab:** Single DQ signal line
2. **SPI Tab:** MOSI and SCK signals
3. **I2C Tab:** SDA and SCL signals

### Browser DevTools Investigation

Examining the page source revealed WebSocket connections streaming live signal data:

```javascript
// Extracted from page source
const ws = new WebSocket(`wss://signals.holidayhackchallenge.com/wire/${wireName}`);

ws.onmessage = (event) => {
    const data = JSON.parse(event.data);
    // Signal data arrives as: { line: number, v: 0|1, t: timestamp }
};
```

**WebSocket Endpoints Discovered:**
- `wss://signals.holidayhackchallenge.com/wire/dq` (1-Wire)
- `wss://signals.holidayhackchallenge.com/wire/mosi` (SPI data)
- `wss://signals.holidayhackchallenge.com/wire/sck` (SPI clock)
- `wss://signals.holidayhackchallenge.com/wire/sda` (I2C data)
- `wss://signals.holidayhackchallenge.com/wire/scl` (I2C clock)

### Browser Buffer Limitation Discovery

Through testing, we discovered a critical limitation: **The browser implementation buffers only 500 bits per wire**, which proved insufficient to capture complete transmission loops.

---

## Signal Capture Methodology

### Approach 1: Browser Console Capture (Initial)

**Method:** Inject JavaScript into browser console to export buffered signals

**Advantages:**
- No additional tools required
- Direct access to WebSocket data
- Easy to implement

**Disadvantages:**
- Limited to 500 bits per wire
- Cannot capture all protocols simultaneously (tab switching disconnects WebSockets)
- No control over capture timing

**Implementation:**

```javascript
// Browser console code to export signals
const signals = {
    dq: [],
    mosi: [],
    sck: [],
    sda: [],
    scl: []
};

// Capture signals (run while viewing each tab)
// Export to JSON
console.save(signals, 'signal_data.json');
```

### Approach 2: Extended WebSocket Capture (Solution)

After determining that 500 bits was insufficient, we developed a Python script to capture extended signal data directly from the WebSocket endpoints.

**Implementation:** See `capture_websockets.py` in repository

**Key Features:**
- Connects to all 5 WebSocket endpoints simultaneously
- Captures for 90 seconds or 10,000 bits per wire (whichever comes first)
- Outputs timestamped JSON file
- Automatic cleanup and graceful shutdown

**Usage:**

```bash
# Create Python virtual environment (recommended)
python3 -m venv burp_venv
source burp_venv/bin/activate

# Install dependencies
pip install websockets

# Run capture script
python capture_websockets.py
```

**Output Format:**

```json
{
  "dq": [1, 0, 1, 0, ...],
  "mosi": [0, 1, 1, 0, ...],
  "sck": [0, 0, 1, 1, ...],
  "sda": [1, 1, 0, 1, ...],
  "scl": [0, 0, 0, 1, ...]
}
```

### Approach 3: Burp Suite Proxy Capture (Alternative)

For those who prefer GUI tools or need to analyze the capture process itself, Burp Suite provides excellent WebSocket interception capabilities.

**Setup Steps:**

1. **Install Burp Suite Community Edition**
   ```bash
   wget "https://portswigger.net/burp/releases/download?product=community&version=latest&type=Linux"
   chmod +x burpsuite_community_linux.sh
   sudo ./burpsuite_community_linux.sh
   ```

2. **Configure Firefox Proxy**
   - Settings → Network Settings → Manual proxy configuration
   - HTTP Proxy: `127.0.0.1`, Port: `8080`
   - HTTPS Proxy: `127.0.0.1`, Port: `8080`

3. **Install Burp CA Certificate**
   - Navigate to `http://burp` in Firefox
   - Download `cacert.der`
   - Firefox → Settings → Privacy & Security → Certificates → Import
   - Trust for identifying websites

4. **Capture WebSocket Traffic**
   - Burp Suite → Proxy → Intercept: OFF (let traffic flow)
   - Navigate to challenge URL
   - Click all three tabs (1-Wire, SPI, I2C)
   - Capture for 90+ seconds
   - View: Proxy → WebSocket History

5. **Export Captured Data**
   - Select each WebSocket connection
   - Copy messages to text files
   - Parse JSON messages to extract bit values

---

## Protocol Decoding

### SPI Decoding

SPI decoding requires careful attention to clock polarity, clock phase, and bit order. We implemented decoders for all four common SPI modes.

#### SPI Decoder Implementation

```javascript
function decodeSPI(mosi, sck, msbFirst = true, risingEdge = true) {
    const bytes = [];
    let currentByte = 0;
    let bitCount = 0;
    
    for (let i = 1; i < Math.min(mosi.length, sck.length); i++) {
        // Detect clock edge
        const edge = risingEdge 
            ? (sck[i-1] === 0 && sck[i] === 1)  // Rising: 0→1
            : (sck[i-1] === 1 && sck[i] === 0); // Falling: 1→0
        
        if (edge) {
            const bit = mosi[i];
            
            // Build byte based on bit order
            if (msbFirst) {
                currentByte = (currentByte << 1) | bit;  // MSB first: shift left
            } else {
                currentByte = currentByte | (bit << bitCount);  // LSB first: shift right
            }
            
            bitCount++;
            
            // Complete byte
            if (bitCount === 8) {
                bytes.push(currentByte);
                currentByte = 0;
                bitCount = 0;
            }
        }
    }
    
    return bytes;
}
```

#### SPI Decoding Results

**Configuration: MSB-First, Rising Edge**

```
Decoded Message (31 bytes):
94 90 e5 0c f4 c9 15 05 e4 c4 b4 35 24 49 25 c1 
d2 58 00 da 5d 4a 44 97 40 83 65 40 d0 d5 2e
```

**Statistical Analysis:**

```javascript
// Shannon Entropy Calculation
function calculateEntropy(data) {
    const frequencies = new Array(256).fill(0);
    data.forEach(byte => frequencies[byte]++);
    
    let entropy = 0;
    const length = data.length;
    
    for (let freq of frequencies) {
        if (freq > 0) {
            const p = freq / length;
            entropy -= p * Math.log2(p);
        }
    }
    
    return entropy;
}

// Result: 4.76 bits per byte
// Analysis: Suggests encrypted English text (typical entropy: 4-5 bits)
//           Random data would have entropy closer to 8 bits
```

**Interpretation:**
- Entropy of 4.76 bits indicates this is likely **encrypted English text**, not random data
- Consistent 31-byte message found at positions 249 and 299 in extended capture
- No readable ASCII patterns in any decoding variant
- This is our **encrypted ciphertext** waiting for the XOR key

### I2C Decoding

I2C decoding is more complex due to START/STOP conditions, address handling, and ACK/NAK bits.

#### I2C Decoder Implementation

```javascript
function decodeI2C(sda, scl) {
    const transactions = [];
    let i = 0;
    
    while (i < Math.min(sda.length, scl.length) - 1) {
        // Look for START condition: SDA falls while SCL high
        if (scl[i] === 1 && sda[i] === 1 && sda[i+1] === 0) {
            const transaction = { 
                address: null, 
                rw: null,      // 0=Write, 1=Read
                data: [] 
            };
            i++;
            
            // Read address byte (7 bits + R/W bit)
            let addressByte = 0;
            let bitCount = 0;
            
            while (i < scl.length - 1 && bitCount < 8) {
                // Rising edge of SCL
                if (scl[i] === 0 && scl[i+1] === 1) {
                    i++;
                    addressByte = (addressByte << 1) | sda[i];
                    bitCount++;
                }
                i++;
            }
            
            // Extract 7-bit address and R/W bit
            transaction.address = addressByte >> 1;  // Upper 7 bits
            transaction.rw = addressByte & 1;        // Lowest bit
            
            // Skip ACK bit
            while (i < scl.length - 1 && !(scl[i] === 0 && scl[i+1] === 1)) i++;
            i += 2;
            
            // Read data bytes until STOP
            while (i < scl.length - 1) {
                // Check for STOP: SDA rises while SCL high
                if (scl[i] === 1 && sda[i] === 0 && sda[i+1] === 1) {
                    break;
                }
                
                // Read data byte
                let dataByte = 0;
                bitCount = 0;
                
                while (i < scl.length - 1 && bitCount < 8) {
                    if (scl[i] === 0 && scl[i+1] === 1) {
                        i++;
                        dataByte = (dataByte << 1) | sda[i];
                        bitCount++;
                    }
                    i++;
                    if (bitCount === 8) break;
                }
                
                if (bitCount === 8) {
                    transaction.data.push(dataByte);
                }
                
                // Skip ACK/NAK
                while (i < scl.length - 1 && !(scl[i] === 0 && scl[i+1] === 1)) i++;
                i += 2;
            }
            
            if (transaction.data.length > 0) {
                transactions.push(transaction);
            }
        }
        i++;
    }
    
    return transactions;
}
```

#### I2C Decoding Results

**Initial 500-Bit Capture:**

| Device Address | Data Length | Operation | Data (first 20 bytes) |
|----------------|-------------|-----------|----------------------|
| 0x00 | 19 bytes | Write | 08 84 02 88 80 46 bc 08 8c 78 01 6c b6 80 80 46 49 7b 8c |
| 0x04 | 9 bytes | Write | Multiple short transactions |
| 0x08 | 10 bytes | Write | Various data patterns |

**Extended 10,000-Bit Capture:**

| Device Address | Data Length | Operation | Note |
|----------------|-------------|-----------|------|
| 0x04 | 52 bytes | Write | Moderate dataset |
| 0x25 | 126 bytes | Write | Large dataset |
| 0x6c | 366 bytes | Read | **Largest dataset** - Primary candidate for key |

**Sample I2C Transaction:**

```
Transaction: Device 0x6c (Read)
Address Byte: 11011000 (0xD8 = 0x6C << 1 | 1)
              └─────┬─────┘ └─ R/W bit (1=Read)
                7-bit addr

Data (first 31 bytes):
b3 7b 1d 98 77 7f 9a 4a 8e bd de 98 9d f0 20 36 
80 20 23 f4 40 61 30 20 b1 10 16 c2 eb 80 01
```

### 1-Wire Analysis

The 1-Wire DQ line consistently showed an alternating pattern (1,0,1,0...) with entropy near 1.0 bit, indicating it's likely in idle state or serving as a clock reference.

```
DQ Signal Pattern:
101010101010101010101010101010101010...

Analysis:
- Perfect alternation suggests clock/idle state
- One anomaly found at position 353: three consecutive 1s
- May require extended capture to see actual data transmission
- Not currently a candidate for the XOR key
```

---

## Decryption Attempts

### XOR Decryption Theory

XOR (Exclusive OR) encryption is a simple symmetric cipher where plaintext is XORed with a key:

```
Ciphertext = Plaintext ⊕ Key
Plaintext = Ciphertext ⊕ Key

Properties:
- XOR is its own inverse: (A ⊕ B) ⊕ B = A
- Key reuse: If key is shorter than plaintext, it repeats
- Bitwise operation: Each bit is XORed independently
```

### XOR Implementation

```javascript
function xorDecrypt(encrypted, key) {
    const result = [];
    for (let i = 0; i < encrypted.length; i++) {
        // Key repeats if shorter than encrypted data
        result.push(encrypted[i] ^ key[i % key.length]);
    }
    return result;
}
```

### Systematic Decryption Attempts

We conducted an exhaustive search through all reasonable key sources:

#### Attempt 1: Direct I2C Device Data

**Hypothesis:** One I2C device contains the 31-byte XOR key

**Method:**
```javascript
// Try each I2C device's data as key
for (const [address, data] of i2cDevices) {
    if (data.length >= 31) {
        const key = data.slice(0, 31);
        const decrypted = xorDecrypt(spiEncrypted, key);
        checkForFlag(decrypted);
    }
}
```

**Results:**

| Device | Key Source | Decrypted Output (first 20 bytes) | Flag Found? |
|--------|-----------|-----------------------------------|-------------|
| 0x04 | First 31 bytes | `2e 10 73 05 68 45 cd f1 78 2a e8 d3 8a a3 92 9f ca 0b ec 14` | ❌ |
| 0x25 | First 31 bytes | `ac 8c fe ee 5d 4b 32 09 81 04 26 5a 03 22 39 b2 65 f5 49 71` | ❌ |
| 0x6c | First 31 bytes | `91 69 0c ba 64 4c b8 58 8f 99 d9 b8 be e2 01 14 93 22 11 e4` | ❌ |

**Conclusion:** None of the direct I2C device data produced readable plaintext

#### Attempt 2: All SPI Decoding Variants

**Hypothesis:** SPI message might be decoded with different parameters

**Variants Tested:**

1. MSB-first, Rising edge
2. MSB-first, Falling edge
3. LSB-first, Rising edge
4. LSB-first, Falling edge

**Results:** All variants produced different byte sequences, but XOR attempts with I2C keys failed for all combinations

#### Attempt 3: All I2C Decoding Variants

**Hypothesis:** I2C key might need different decoding parameters

**Method:**
```javascript
const i2cVariants = [
    { msb: true, rising: true, name: 'MSB-first, Rising edge' },
    { msb: true, rising: false, name: 'MSB-first, Falling edge' },
    { msb: false, rising: true, name: 'LSB-first, Rising edge' },
    { msb: false, rising: false, name: 'LSB-first, Falling edge' }
];
```

**Results:** Different I2C decoding parameters produced different keys, but none successfully decrypted the SPI message

#### Attempt 4: Sliding Window Brute Force

**Hypothesis:** Key might be at any 31-byte offset within I2C data

**Method:**
```javascript
// Try all possible 31-byte windows
for (let offset = 0; offset <= i2cData.length - 31; offset++) {
    const key = i2cData.slice(offset, offset + 31);
    const decrypted = xorDecrypt(spiEncrypted, key);
    
    // Check for flag patterns
    if (containsFlag(decrypted)) {
        console.log(`FLAG FOUND at offset ${offset}!`);
    }
}
```

**Results:** Tested 514 different offsets across all I2C data - no flag found

#### Attempt 5: Time-Synchronized Decoding

**Hypothesis:** Key comes from I2C data captured at same time as SPI message

**Method:**
```javascript
// SPI message found at byte position 249 (~2000 bits)
// Try I2C data from same time window
const windows = [
    { start: 1500, end: 2500 },  // Around SPI position
    { start: 2000, end: 3000 },  // Bits 2000-3000
    // ... etc
];
```

**Results:** Time-synchronized windows produced different I2C transactions, but no successful decryption

#### Attempt 6: Alternative Key Constructions

**Methods Tested:**

1. **I2C addresses as part of key:** `[address, ...data]`
2. **Reversed key:** `key.reverse()`
3. **Last 31 bytes instead of first**
4. **XOR accumulation:** `key[i] = key[i-1] ^ i2cData[i]`
5. **Single-byte XOR:** Brute force all 256 possible keys (0x00-0xFF)
6. **Combined device data:** Concatenate data from multiple devices

**Results:** None produced readable plaintext or flag patterns

### Decryption Attempts Summary

| Attempt Type | Variants Tested | Keys Tried | Result |
|--------------|-----------------|------------|--------|
| Direct I2C device data | 3 devices × 2 lengths | 6 | ❌ |
| SPI decoding variants | 4 modes | 4 | ❌ |
| I2C decoding variants | 4 modes × 3 devices | 12 | ❌ |
| Sliding window | All offsets | 514 | ❌ |
| Time-synchronized | 5 windows | 5 | ❌ |
| Alternative constructions | 6 methods | 100+ | ❌ |
| **TOTAL** | | **641+** | ❌ |

---

## Extended Capture Solution

### Extended Capture Results

**Capture Statistics:**

```
=== Extended Capture Summary ===
Wire: dq    - 10,000 bits captured
Wire: mosi  - 10,000 bits captured  
Wire: sck   - 10,000 bits captured
Wire: sda   - 10,000 bits captured
Wire: scl   - 10,000 bits captured

Total: 50,000 bits (20x browser limit)
Capture duration: 90 seconds
```

**SPI Analysis:**

```
=== SPI Decoding (Extended Capture) ===
Total bytes decoded: 624 bytes
Encrypted message found at positions: 249, 299

31-byte encrypted message (consistent across occurrences):
94 90 e5 0c f4 c9 15 05 e4 c4 b4 35 24 49 25 c1 
d2 58 00 da 5d 4a 44 97 40 83 65 40 d0 d5 2e
```

**I2C Analysis:**

```
=== I2C Transactions (Extended Capture) ===
Total transactions: 3
Total I2C bytes: 544 bytes

Device 0x04:  52 bytes
Device 0x25: 126 bytes  
Device 0x6c: 366 bytes (largest)
```

### Current Status

**✅ Accomplished:**
- Successfully captured extended signal data (10,000 bits per wire)
- Decoded SPI encrypted message (31 bytes, entropy 4.76 bits)
- Decoded I2C transactions from 3 devices (544 total bytes)
- Identified repeating SPI message pattern (positions 249, 299)
- Implemented comprehensive decoding tools
- Tested 641+ different key combinations

**❌ Still Needed:**
- Find correct XOR key from I2C data
- Decrypt SPI message to reveal flag
- Possible missing piece:
  - Different protocol interpretation
  - Metadata-based key (addresses, timing, etc.)
  - Multi-device key combination
  - Challenge-specific encoding scheme

---

## Tools and Scripts

### Python Scripts

#### `capture_websockets.py` - Extended Signal Capture

**Purpose:** Capture complete transmission loop from all WebSocket endpoints

**Features:**
- Connects to all 5 wires simultaneously
- Captures 10,000 bits or 90 seconds (whichever comes first)
- Outputs timestamped JSON file
- Graceful error handling and cleanup

**Dependencies:**
```bash
pip install websockets
```

**Usage:**
```bash
python capture_websockets.py
# Output: signals_extended_YYYYMMDD_HHMMSS.json
```

### Node.js Analysis Scripts

All scripts located in `/home/claude/` directory:

#### Core Decoders

**`decode_signals.js`** - Basic MSB-first decoder
```bash
node decode_signals.js signal_data.json
```

**`decode_all_signals.js`** - Complete decoder with all variants
```bash
node decode_all_signals.js signal_data.json
```

**`analyze_i2c_detailed.js`** - I2C protocol analyzer with transaction parsing
```bash
node analyze_i2c_detailed.js signal_data.json
```

#### Specialized Analysis

**`analyze_spi_deep.js`** - SPI pattern analysis and entropy calculation

**`analyze_dq.js`** - 1-Wire signal pattern analyzer  

**`try_all_combos.js`** - XOR with all MSB/LSB combinations

**`brute_force_key.js`** - Sliding window brute force search

**`time_sync_decode.js`** - Time-synchronized I2C/SPI correlation

### Burp Suite Configuration

See [Extended Capture Solution](#extended-capture-solution) section for complete Burp Suite setup guide.

---

## Lessons Learned

### Technical Insights

#### 1. Buffer Limitations in Web Applications

**Issue:** Browser-based signal capture limited to 500 bits per wire

**Learning:** Always verify data completeness before analysis. When dealing with continuous data streams, browser implementations may have hidden buffer limits. This challenge taught the importance of:
- Checking capture completeness
- Using external tools for comprehensive data collection
- Understanding WebSocket lifecycle and limitations

**Solution:** Direct WebSocket connection via Python script bypassed browser limitations

#### 2. Protocol Parameter Space Exploration

**Issue:** Multiple valid decoding parameters for each protocol

**Learning:** Serial protocols have numerous configuration options:
- SPI: 4 modes (CPOL/CPHA combinations) × 2 bit orders = 8 variants
- I2C: 2 bit orders × 2 edge polarities = 4 variants  
- Combined: Potentially 32+ valid decoding combinations

**Best Practice:** Implement systematic variant testing with automated validation

#### 3. Entropy Analysis for Encryption Detection

**Technique:** Shannon entropy calculation helps identify data types

```javascript
// Entropy ranges:
// - Random data: ~8 bits per byte
// - Encrypted English: ~4-5 bits per byte
// - Plain ASCII: ~2-3 bits per byte
// - Repetitive data: <2 bits per byte
```

**Application:** Our SPI message entropy of 4.76 bits immediately indicated encrypted text rather than random data or unencrypted content.

#### 4. Multi-Protocol Challenges Require Simultaneous Capture

**Issue:** Tab switching in browser disconnected inactive WebSocket connections

**Learning:** When multiple protocols interact, capture all signals simultaneously to maintain timing relationships and catch synchronization events.

### CTF Strategy Insights

#### Incremental Complexity

This challenge exemplified multi-stage CTF problem solving:
1. **Stage 1:** Understand protocols (research required)
2. **Stage 2:** Capture signals (tooling challenge)
3. **Stage 3:** Decode protocols (implementation challenge)
4. **Stage 4:** Find encryption key (pattern analysis)
5. **Stage 5:** Decrypt message (crypto application)

Each stage builds on previous work - persistence through partial progress is key.

#### Tool Development as Part of Solution

Rather than finding existing tools, we developed custom solutions:
- Protocol decoders tailored to challenge format
- WebSocket capture automation
- Analysis scripts for systematic testing

**Takeaway:** Don't be afraid to write custom tools - they often provide better insight than generic solutions.

#### Documentation During Exploration

Maintaining detailed notes throughout the challenge process:
- Captured all intermediate results
- Documented failed attempts (preventing redundant work)
- Preserved analysis scripts for future reference

**Benefit:** This write-up was possible because we documented the journey, not just the solution.

### Real-World Applications

#### Protocol Analysis Skills

The techniques learned apply directly to:
- **Hardware debugging:** Logic analyzer interpretation
- **Embedded systems:** Firmware reverse engineering
- **IoT security:** Device communication analysis
- **Industrial control systems:** SCADA protocol understanding

#### Signal Intelligence

Modern security operations increasingly involve:
- Network protocol analysis
- RF signal processing
- Binary data interpretation
- Multi-source correlation

This challenge simulates real-world signal intelligence scenarios where operators must decode unfamiliar protocols with minimal documentation.

### Open Questions

These remain unanswered and represent the ongoing nature of this challenge:

1. **Where is the XOR key?**
   - Is it in the I2C data we captured?
   - Does it require a specific I2C device address sequence?
   - Is there a timing component we're missing?

2. **Are all signals necessary?**
   - Does 1-Wire contain critical data we haven't seen?
   - Are SPI and I2C meant to be combined somehow?

3. **Is there metadata encoding?**
   - Could device addresses form part of the key?
   - Does transaction timing matter?
   - Are there protocol violations carrying data?

4. **Challenge mechanism:**
   - How does the website's native decoder work?
   - What do they see that we don't in the same capture?

---

## Next Steps

### Recommended Actions

1. **Upload Extended Capture to Challenge Website**
   - Use official decoder interface
   - Compare results with our decoding
   - Look for hints in UI feedback

2. **Analyze Capture Timing**
   - Check timestamps in WebSocket messages
   - Look for synchronization markers
   - Map timing relationships between protocols

3. **Review I2C Transaction Sequences**
   - Look for register read patterns
   - Check if device addresses encode information
   - Analyze multi-transaction sequences

4. **Community Collaboration**
   - Share findings with other challengers
   - Compare captured data
   - Pool analysis approaches

### Alternative Approaches to Consider

1. **Frequency Analysis**
   - Apply cryptanalysis techniques to ciphertext
   - Look for patterns in encrypted data
   - Statistical attacks on XOR cipher

2. **Reverse Engineering Challenge Website**
   - Analyze JavaScript decoder implementation
   - Compare with our decoding logic
   - Identify any preprocessing steps we're missing

3. **Extended Protocol Research**
   - Research vendor-specific protocol extensions
   - Check for challenge-specific encoding schemes
   - Review Dallas/Maxim 1-Wire documentation more thoroughly

---

## References

### Protocol Specifications

**SPI:**
- Motorola SPI Block Guide
- [SPI Tutorial - SparkFun](https://learn.sparkfun.com/tutorials/serial-peripheral-interface-spi)

**I2C:**
- NXP I2C-bus specification and user manual (UM10204)
- [I2C Protocol Tutorial](https://www.analog.com/en/technical-articles/i2c-primer-what-is-i2c-part-1.html)

**1-Wire:**
- Maxim Integrated 1-Wire Protocol Overview
- [Dallas 1-Wire Protocol](https://www.maximintegrated.com/en/products/ibutton-one-wire/one-wire.html)

### Cryptography

- Applied Cryptography by Bruce Schneier
- [XOR Cipher Analysis](https://en.wikipedia.org/wiki/XOR_cipher)
- Shannon Entropy calculation methods

### Tools and Libraries

- [websockets Python library](https://pypi.org/project/websockets/)
- [Burp Suite Community Edition](https://portswigger.net/burp/communitydownload)
- Node.js signal processing techniques

### SANS Holiday Hack Challenge

- [SANS Holiday Hack Challenge 2025](https://www.sans.org/holiday-hack-challenge/)
- [Counter Hack](https://www.counterhack.com/)
- Previous years' write-ups and solutions

---

## Acknowledgments

**Challenge Creators:** Counter Hack and SANS Institute  
**Author:** SFC David P. Collette, Regional Cyber Center - Korea (RCC-K)  
**Tools:** Claude AI for analysis assistance and documentation

---

## Appendix: Data Files

### Signal Capture Files

All captured signal data available in repository:

- `signal_data.json` - Initial 500-bit capture (browser-limited)
- `signals_extended_20251231_161742.json` - Extended 10,000-bit capture (Python script)
- `signal_data_full.json` - 30-second DQ-only capture
- `signal_data_complete.json` - Complete SPI capture
- `signal_with_i2c.json` - Multi-protocol capture

### Decoded Data

**SPI Encrypted Message:**
```
94 90 e5 0c f4 c9 15 05 e4 c4 b4 35 24 49 25 c1 
d2 58 00 da 5d 4a 44 97 40 83 65 40 d0 d5 2e
```

**I2C Device 0x6c (First 31 Bytes):**
```
b3 7b 1d 98 77 7f 9a 4a 8e bd de 98 9d f0 20 36 
80 20 23 f4 40 61 30 20 b1 10 16 c2 eb 80 01
```

---

## Status: Challenge Continues

This challenge remains unsolved. The journey documented here represents significant progress in protocol analysis, signal capture, and systematic cryptanalysis - all valuable skills for cybersecurity professionals.

**The search for the XOR key continues...**

---

*Last Updated: December 31, 2025*  
*Write-up Version: 1.0*  
*Competition Submission: SANS Holiday Hack Challenge 2025*
